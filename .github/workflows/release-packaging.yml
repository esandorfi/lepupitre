name: Release Packaging

on:
  workflow_dispatch:
  push:
    tags:
      - "v*"

permissions:
  contents: write

env:
  HOMEBREW_TAP: esandorfi/homebrew-lepupitre
  HOMEBREW_CASK: lepupitre
  WINGET_ID: esandorfi.LePupitre
  LEPUPITRE_REQUIRE_WINDOWS_SIGNING: ${{ vars.LEPUPITRE_REQUIRE_WINDOWS_SIGNING }}
  LEPUPITRE_WINDOWS_SIGNING_PROVIDER: ${{ vars.LEPUPITRE_WINDOWS_SIGNING_PROVIDER }}
  LEPUPITRE_REQUIRE_MACOS_NOTARIZATION: ${{ vars.LEPUPITRE_REQUIRE_MACOS_NOTARIZATION }}

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest, windows-latest]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20.19.0"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: "10"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Validate signing/notarization prerequisites
        shell: bash
        env:
          SIGNPATH_API_TOKEN: ${{ secrets.SIGNPATH_API_TOKEN }}
          SIGNPATH_ORGANIZATION_ID: ${{ secrets.SIGNPATH_ORGANIZATION_ID }}
          SIGNPATH_PROJECT_SLUG: ${{ secrets.SIGNPATH_PROJECT_SLUG }}
          SIGNPATH_SIGNING_POLICY_SLUG: ${{ secrets.SIGNPATH_SIGNING_POLICY_SLUG }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          chmod +x scripts/check-release-signing.sh
          ./scripts/check-release-signing.sh

      - name: Install CMake (macOS)
        if: matrix.os == 'macos-latest'
        run: brew install cmake llvm

      - name: Configure libclang (macOS)
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          set -euo pipefail
          LLVM_PREFIX="$(brew --prefix llvm)"
          echo "LIBCLANG_PATH=${LLVM_PREFIX}/lib" >> "$GITHUB_ENV"
          echo "${LLVM_PREFIX}/bin" >> "$GITHUB_PATH"

      - name: Ensure CMake (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          if (-not (Get-Command cmake -ErrorAction SilentlyContinue)) {
            choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System' -y
          }
          cmake --version
          if (-not (Get-Command clang -ErrorAction SilentlyContinue)) {
            choco install llvm -y
          }
          $libclang = "C:\Program Files\LLVM\bin\libclang.dll"
          if (-not (Test-Path $libclang)) {
            throw "libclang.dll not found at $libclang"
          }
          "LIBCLANG_PATH=C:\Program Files\LLVM\bin" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "C:\Program Files\LLVM\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Install JS deps
        run: pnpm -C desktop install

      - name: Build ASR sidecar
        shell: bash
        run: ./scripts/build-asr-sidecar.sh --copy

      - name: Ensure sidecar resource filenames
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p desktop/src-tauri/sidecar
          if [ ! -f desktop/src-tauri/sidecar/lepupitre-asr ] && [ -f desktop/src-tauri/sidecar/lepupitre-asr.exe ]; then
            cp desktop/src-tauri/sidecar/lepupitre-asr.exe desktop/src-tauri/sidecar/lepupitre-asr
            chmod +x desktop/src-tauri/sidecar/lepupitre-asr
          fi
          if [ ! -f desktop/src-tauri/sidecar/lepupitre-asr.exe ] && [ -f desktop/src-tauri/sidecar/lepupitre-asr ]; then
            cp desktop/src-tauri/sidecar/lepupitre-asr desktop/src-tauri/sidecar/lepupitre-asr.exe
          fi

      - name: Verify ASR sidecar binary
        run: node scripts/verify-asr-sidecar.mjs

      - name: Cache whisper tiny model (macOS)
        if: matrix.os == 'macos-latest'
        uses: actions/cache@v4
        with:
          path: /tmp/ggml-tiny.bin
          key: whisper-tiny-${{ runner.os }}-be07e048

      - name: Cache whisper tiny model (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/cache@v4
        with:
          path: ${{ runner.temp }}/ggml-tiny.bin
          key: whisper-tiny-${{ runner.os }}-be07e048

      - name: ASR smoke test (macOS)
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f /tmp/ggml-tiny.bin ]; then
            curl -L -o /tmp/ggml-tiny.bin https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin
          fi
          echo "be07e048e1e599ad46341c8d2a135645097a538221678b7acdd1b1919c6e1b21  /tmp/ggml-tiny.bin" | shasum -a 256 -c -
          chmod +x desktop/src-tauri/sidecar/lepupitre-asr
          LEPUPITRE_ASR_SMOKE=1 \
            LEPUPITRE_ASR_SIDECAR="$PWD/desktop/src-tauri/sidecar/lepupitre-asr" \
            LEPUPITRE_ASR_MODEL_PATH=/tmp/ggml-tiny.bin \
            ./scripts/asr-smoke.sh "$PWD/desktop/src-tauri/sidecar/lepupitre-asr" /tmp/ggml-tiny.bin

      - name: ASR smoke test (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $modelPath = Join-Path $env:RUNNER_TEMP "ggml-tiny.bin"
          if (-not (Test-Path $modelPath)) {
            Invoke-WebRequest -Uri "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin" -OutFile $modelPath
          }
          $expected = "be07e048e1e599ad46341c8d2a135645097a538221678b7acdd1b1919c6e1b21"
          $actual = (Get-FileHash -Algorithm SHA256 $modelPath).Hash.ToLower()
          if ($actual -ne $expected) { throw "Model checksum mismatch: $actual" }
          $sidecarDir = Join-Path $pwd "desktop\\src-tauri\\sidecar"
          $sidecarUnix = Join-Path $sidecarDir "lepupitre-asr"
          $sidecarExe = Join-Path $sidecarDir "lepupitre-asr.exe"
          if (-not (Test-Path $sidecarUnix) -and (Test-Path $sidecarExe)) {
            Copy-Item -LiteralPath $sidecarExe -Destination $sidecarUnix -Force
          }
          if (-not (Test-Path $sidecarExe) -and (Test-Path $sidecarUnix)) {
            Copy-Item -LiteralPath $sidecarUnix -Destination $sidecarExe -Force
          }
          if (-not (Test-Path $sidecarUnix) -or -not (Test-Path $sidecarExe)) {
            Write-Host "Current sidecar directory contents:"
            if (Test-Path $sidecarDir) {
              Get-ChildItem -LiteralPath $sidecarDir | Format-Table -AutoSize
            }
            throw "Missing Tauri sidecar resources; expected both lepupitre-asr and lepupitre-asr.exe"
          }
          $sidecar = Join-Path $pwd "desktop\\src-tauri\\sidecar\\lepupitre-asr.exe"
          $env:LEPUPITRE_ASR_SMOKE = "1"
          $env:LEPUPITRE_ASR_SIDECAR = $sidecar
          $env:LEPUPITRE_ASR_MODEL_PATH = $modelPath
          cargo test --manifest-path desktop\\src-tauri\\Cargo.toml asr_sidecar_smoke_decode

      - name: Build artifacts (manual run)
        if: github.event_name == 'workflow_dispatch'
        run: pnpm -C desktop build

      - name: Upload artifacts (manual run)
        if: github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: lepupitre-${{ matrix.os }}
          path: |
            desktop/src-tauri/target/release/bundle/**

      - name: Build and attach to GitHub release
        if: startsWith(github.ref, 'refs/tags/')
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          projectPath: desktop
          releaseName: "LePupitre ${{ github.ref_name }}"
          tagName: ${{ github.ref_name }}
          releaseBody: |
            ## Code signing policy
            See [Code signing policy](https://github.com/${{ github.repository }}/blob/main/docs/operations/CODE_SIGNING_POLICY.md).
          releaseDraft: false
          prerelease: false

      - name: Verify Windows installer signatures when required
        if: matrix.os == 'windows-latest' && (github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/'))
        shell: pwsh
        run: |
          $required = "$env:LEPUPITRE_REQUIRE_WINDOWS_SIGNING".ToLower()
          if ($required -notin @("1", "true", "yes", "on")) {
            Write-Host "Windows signing verification disabled."
            exit 0
          }

          $targets = @()
          $targets += Get-ChildItem -Path "desktop/src-tauri/target/release/bundle/msi" -Recurse -File -ErrorAction SilentlyContinue | Where-Object { $_.Extension -eq ".msi" }
          $targets += Get-ChildItem -Path "desktop/src-tauri/target/release/bundle/nsis" -Recurse -File -ErrorAction SilentlyContinue | Where-Object { $_.Extension -eq ".exe" }
          if ($targets.Count -eq 0) {
            throw "Windows signing required but no MSI/NSIS installers were found."
          }

          $invalid = @()
          foreach ($file in $targets) {
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            if ($sig.Status -ne "Valid") {
              $invalid += "$($file.FullName) -> $($sig.Status)"
            }
          }

          if ($invalid.Count -gt 0) {
            $invalid | ForEach-Object { Write-Host "::error::$_" }
            throw "Windows signing required but one or more installers are unsigned or invalid."
          }

          Write-Host "Windows installer signature verification passed."

      - name: Verify macOS signatures/notarization when required
        if: matrix.os == 'macos-latest' && (github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/'))
        shell: bash
        run: |
          set -euo pipefail
          case "${LEPUPITRE_REQUIRE_MACOS_NOTARIZATION:-}" in
            1|true|TRUE|yes|YES|on|ON) ;;
            *)
              echo "macOS notarization verification disabled."
              exit 0
              ;;
          esac

          APP_PATH="$(find desktop/src-tauri/target/release/bundle -type d -name '*.app' | head -n 1)"
          DMG_PATH="$(find desktop/src-tauri/target/release/bundle -type f -name '*.dmg' | head -n 1)"

          if [ -z "${APP_PATH}" ]; then
            echo "::error::macOS notarization required but no .app bundle found."
            exit 1
          fi

          codesign --verify --deep --strict --verbose=2 "${APP_PATH}"
          spctl --assess --type execute --verbose=4 "${APP_PATH}"

          if [ -n "${DMG_PATH}" ]; then
            xcrun stapler validate "${DMG_PATH}"
          fi

          echo "macOS signature/notarization verification passed."

  update-homebrew:
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Install tools
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          if [ -z "${HOMEBREW_TAP_TOKEN}" ]; then
            echo "HOMEBREW_TAP_TOKEN not set; skipping optional Homebrew update."
            exit 0
          fi
          sudo apt-get update && sudo apt-get install -y jq
      - name: Update Homebrew cask
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${HOMEBREW_TAP_TOKEN}" ]; then
            echo "HOMEBREW_TAP_TOKEN not set; skipping optional Homebrew update."
            exit 0
          fi
          VERSION="${GITHUB_REF_NAME#v}"
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${GITHUB_REF_NAME}"
          RELEASE=""
          for ATTEMPT in $(seq 1 20); do
            RELEASE=$(curl -fsSL \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${API_URL}" || true)
            if [ -n "${RELEASE}" ]; then
              DMG_COUNT=$(echo "${RELEASE}" | jq -r '[((.assets // [])[]) | select(.name | test("\\.dmg$"; "i"))] | length')
              if [ "${DMG_COUNT}" -gt 0 ]; then
                break
              fi
              API_MESSAGE=$(echo "${RELEASE}" | jq -r '.message // empty')
              if [ -n "${API_MESSAGE}" ]; then
                echo "Release lookup not ready (attempt ${ATTEMPT}/20): ${API_MESSAGE}"
              else
                echo "Release found but no DMG assets yet (attempt ${ATTEMPT}/20)."
              fi
            else
              echo "Empty release API response (attempt ${ATTEMPT}/20)."
            fi
            if [ "${ATTEMPT}" -lt 20 ]; then
              sleep 15
            fi
          done
          ARM_URL=$(echo "${RELEASE}" | jq -r '((.assets // [])[] | select(.name | test("\\.dmg$"; "i")) | select(.name | test("aarch64|arm64"; "i")) | .browser_download_url) // empty' | head -n 1)
          INTEL_URL=$(echo "${RELEASE}" | jq -r '((.assets // [])[] | select(.name | test("\\.dmg$"; "i")) | select(.name | test("x64|x86_64"; "i")) | .browser_download_url) // empty' | head -n 1)
          if [ -z "${ARM_URL}" ] && [ -z "${INTEL_URL}" ]; then
            echo "No DMG assets found after waiting for the release."
            echo "${RELEASE}" | jq -C '.' || echo "${RELEASE}"
            exit 1
          fi
          mkdir -p /tmp/lepupitre
          if [ -n "${ARM_URL}" ]; then
            curl -fL -o /tmp/lepupitre/arm.dmg "${ARM_URL}"
            ARM_SHA=$(shasum -a 256 /tmp/lepupitre/arm.dmg | awk '{print $1}')
            ARM_NAME=$(basename "${ARM_URL}")
          fi
          if [ -n "${INTEL_URL}" ]; then
            curl -fL -o /tmp/lepupitre/intel.dmg "${INTEL_URL}"
            INTEL_SHA=$(shasum -a 256 /tmp/lepupitre/intel.dmg | awk '{print $1}')
            INTEL_NAME=$(basename "${INTEL_URL}")
          fi
          git clone "https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/${HOMEBREW_TAP}.git" homebrew-tap
          mkdir -p "homebrew-tap/Casks"
          if [ -n "${ARM_URL}" ] && [ -n "${INTEL_URL}" ]; then
            cat > "homebrew-tap/Casks/${HOMEBREW_CASK}.rb" <<EOF
          cask "${HOMEBREW_CASK}" do
            version "${VERSION}"
            sha256 arm: "${ARM_SHA}", intel: "${INTEL_SHA}"

            url "https://github.com/${GITHUB_REPOSITORY}/releases/download/v#{version}/#{arch}",
                arch: { arm: "${ARM_NAME}", intel: "${INTEL_NAME}" }

            name "LePupitre"
            desc "Local-first talk coach"
            homepage "https://github.com/${GITHUB_REPOSITORY}"

            app "LePupitre.app"
          end
          EOF
          else
            URL="${ARM_URL:-${INTEL_URL}}"
            SHA="${ARM_SHA:-${INTEL_SHA}}"
            NAME=$(basename "${URL}")
            cat > "homebrew-tap/Casks/${HOMEBREW_CASK}.rb" <<EOF
          cask "${HOMEBREW_CASK}" do
            version "${VERSION}"
            sha256 "${SHA}"

            url "https://github.com/${GITHUB_REPOSITORY}/releases/download/v#{version}/${NAME}"

            name "LePupitre"
            desc "Local-first talk coach"
            homepage "https://github.com/${GITHUB_REPOSITORY}"

            app "LePupitre.app"
          end
          EOF
          fi
          cd homebrew-tap
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "Casks/${HOMEBREW_CASK}.rb"
          git commit -m "Update ${HOMEBREW_CASK} to ${VERSION}"
          git push -u origin HEAD

  update-winget:
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: windows-latest
    needs: build
    steps:
      - name: Update winget package
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WINGETCREATE_TOKEN: ${{ secrets.WINGETCREATE_TOKEN }}
          WINGET_ID: ${{ env.WINGET_ID }}
        shell: pwsh
        run: |
          if (-not $env:WINGETCREATE_TOKEN) {
            Write-Host "WINGETCREATE_TOKEN not set, skipping winget update."
            exit 0
          }
          $version = $env:GITHUB_REF_NAME -replace '^v',''
          $apiUrl = "https://api.github.com/repos/$env:GITHUB_REPOSITORY/releases/tags/$env:GITHUB_REF_NAME"
          $headers = @{
            Authorization = "Bearer $env:GITHUB_TOKEN"
            Accept = "application/vnd.github+json"
          }
          $release = $null
          $asset = $null
          for ($attempt = 1; $attempt -le 20; $attempt++) {
            try {
              $release = Invoke-RestMethod -Headers $headers -Uri $apiUrl
            } catch {
              Write-Host "Release lookup not ready (attempt $attempt/20): $($_.Exception.Message)"
              if ($attempt -eq 20) { throw }
              Start-Sleep -Seconds 15
              continue
            }

            $assets = @()
            if ($null -ne $release -and $null -ne $release.assets) {
              $assets = @($release.assets)
            }

            $asset = $assets | Where-Object { $_.name -like "*.msi" } | Select-Object -First 1
            if (-not $asset) {
              $asset = $assets | Where-Object { $_.name -like "*.exe" } | Select-Object -First 1
            }
            if ($asset) {
              break
            }

            if ($null -ne $release -and ($release.PSObject.Properties.Name -contains 'message') -and $release.message) {
              Write-Host "Release found but not ready (attempt $attempt/20): $($release.message)"
            } else {
              Write-Host "Release found but no installer asset yet (attempt $attempt/20)."
            }
            if ($attempt -lt 20) {
              Start-Sleep -Seconds 15
            }
          }
          if (-not $asset) {
            throw "No installer asset found after waiting for the release assets."
          }
          $url = $asset.browser_download_url
          $installerPath = Join-Path $env:RUNNER_TEMP $asset.name
          Invoke-WebRequest -Uri $url -OutFile $installerPath
          $sha = (Get-FileHash -Algorithm SHA256 $installerPath).Hash.ToLower()
          winget install --id Microsoft.WingetCreate -e --accept-package-agreements --accept-source-agreements

          # Prefer env var token in CI to avoid exposing token via command-line args.
          $env:WINGET_CREATE_GITHUB_TOKEN = $env:WINGETCREATE_TOKEN

          # Check whether the package already exists in winget-pkgs.
          $packagePath = ($env:WINGET_ID -replace '\.', '/')
          $firstChar = $env:WINGET_ID.Substring(0,1).ToLower()
          $manifestPath = "manifests/$firstChar/$packagePath"
          $manifestApi = "https://api.github.com/repos/microsoft/winget-pkgs/contents/$manifestPath"
          $exists = $false
          try {
            Invoke-RestMethod -Headers $headers -Uri $manifestApi | Out-Null
            $exists = $true
          } catch {
            $statusCode = $null
            if ($_.Exception.Response -and $_.Exception.Response.StatusCode) {
              $statusCode = [int]$_.Exception.Response.StatusCode
            }
            if ($statusCode -ne 404) { throw }
          }

          if (-not $exists) {
            Write-Host "winget package '$env:WINGET_ID' does not exist yet in microsoft/winget-pkgs."
            Write-Host "Skipping automated update for this release."
            Write-Host "Bootstrap once by submitting an initial manifest, then release automation can use 'wingetcreate update'."
            exit 0
          }

          wingetcreate update $env:WINGET_ID --version $version --urls $url --submit --no-open
